<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Homework #10</title>
    <link rel="stylesheet" href="css/styles.css">
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.9.4/Chart.js"></script>
</head>

<body>
    <a href="index.html">Home</a>
    <h1>Statistics - Homework #10 [Y.2024-2025]</h1>
    <h1>Theory and Research</h1>

    <h2>General Concept of Sampling Mean and Variance</h2>
    <p>
        In statistics, the <strong>sampling mean</strong> is the average of a set of data points. It is a measure of the
        central tendency of the data and is calculated by summing all the data points and dividing by the number of
        points:
        <br>
        <i>Sample Mean:</i>
        <br>
        \(\bar{x} = \frac{1}{n} \sum_{i=1}^{n} x_i \)
        <br>
        where \( x_1, x_2, \dots, x_n \) are the data points and \( n \) is the number of observations.
    </p>
    <p>
        The <strong>sampling variance</strong> measures the spread of the data points around the sample mean. It is
        computed by averaging the squared differences between each data point and the sample mean:
        <br>
        <i>Sample Variance:</i>
        <br>
        \( s^2 = \frac{1}{n-1} \sum_{i=1}^{n} (x_i - \bar{x})^2 \)
        <br>
        where \( \bar{x} \) is the sample mean and \( n \) is the number of data points.
    </p>
    <p>
        The <strong>sampling distribution</strong> of the sample mean and variance describes how these values behave
        over multiple samples. The mean of the sampling distribution of the sample mean is equal to the population mean,
        and the variance of the sampling distribution of the sample mean is the population variance divided by the
        sample size:
        <br>
        <i>Mean of Sampling Distribution:</i>
        <br>
        \( \mu_{\bar{x}} = \mu \)
        <br>
        <i>Variance of Sampling Distribution:</i>
        <br>
        \( \sigma^2_{\bar{x}} = \frac{\sigma^2}{n} \)
        <br>
        where \( \mu \) and \( \sigma^2 \) are the population mean and variance, respectively, and \( n \) is the sample
        size.
    </p>

    <h2>Lebesgue-Stieltjes Integration and Its Applications</h2>
    <p>
        The <strong>Lebesgue-Stieltjes integration</strong> is a generalization of the Lebesgue integral, developed to
        integrate functions with respect to a more general measure. It is an integral of a function \( f \) with respect
        to a measure \( \mu \) which is derived from a function \( G \), called the Stieltjes function. The
        Lebesgue-Stieltjes integral can be written as:
        <br>
        <i>Lebesgue-Stieltjes Integral:</i>
        <br>
        \( \int_a^b f(x) \, dG(x) = \int_a^b f(x) \, g'(x) dx \)
        <br>
        where \( g(x) \) is a function whose derivative \( g'(x) \) represents the measure \( \mu \). This form of
        integration is useful when the measure is not necessarily derived from a simple distribution, but from a more
        complex function \( G(x) \).
    </p>
    <p>
        One key application of Lebesgue-Stieltjes integration is in <strong>probability theory</strong>. When the
        cumulative distribution function (CDF) \( F(x) \) of a random variable is differentiable, the Lebesgue-Stieltjes
        integral provides a method of calculating the expected value of a random variable. If \( f(x) \) is the
        probability density function (PDF) of the random variable \( X \), then the expected value of \( X \) can be
        written as:
        <br>
        <i>Expected Value:</i>
        <br>
        \( E[X] = \int_{-\infty}^{\infty} x f(x) \, dx \)
        <br>
        where \( f(x) \) is the probability density function.
    </p>
    <p>
        In <strong>measure theory</strong>, Lebesgue-Stieltjes integration plays a vital role in defining integrals with
        respect to general measures, allowing the integration of more general functions and distributions than what is
        possible with Riemann integration. For example, it is crucial for integrating random variables with respect to
        measures that are not necessarily absolutely continuous, such as in the case of discrete distributions or
        distributions with singularities.
    </p>
    <p>
        The versatility of Lebesgue-Stieltjes integration has led to its use in various areas of mathematics and applied
        fields. In probability theory, it provides a framework for understanding and computing expectations in the
        context of both discrete and continuous random variables. It is also widely used in stochastic processes, where
        the integration process is used to model complex random phenomena and time-evolving systems.
    </p>

    <h2>Riemann Integration</h2>
    <p>
        The <strong>Riemann integral</strong> is the classical concept of integration in calculus, where we define the
        integral of a function over an interval by partitioning the interval into smaller subintervals, computing the
        sum of the function's values multiplied by the subinterval widths, and taking the limit as the partition gets
        finer. Mathematically, the Riemann integral of a function \( f \) over the interval \([a, b]\) is expressed as:
        <br>
        <i>Riemann Integral:</i>
        <br>
        \( \int_a^b f(x) \, dx = \lim_{\|P\| \to 0} \sum_{i=1}^{n} f(x_i^*) \Delta x_i \)
        <br>
        where \( P \) is a partition of the interval \([a, b]\), \( x_i^* \) is a sample point from each subinterval,
        and \( \Delta x_i \) is the width of the subinterval. The limit is taken as the norm of the partition \( \|P\|
        \) (the width of the largest subinterval) approaches 0.
    </p>
    <p>
        The Riemann integral is well-suited for integrating functions that are continuous over the interval \([a, b]\).
        However, it has limitations. Specifically, it does not handle discontinuous functions or functions with certain
        irregularities (e.g., functions with jumps or infinite discontinuities) well. This is where the Lebesgue
        integral, including Lebesgue-Stieltjes integration, becomes more powerful, as it can handle these types of
        functions by integrating with respect to a more general measure.
    </p>
    <p>
        Despite its limitations, the Riemann integral remains widely used in many areas of mathematics and applied
        sciences. It is often used for practical problems in physics, engineering, and economics, where the functions of
        interest are continuous and smooth over the region of integration. The Riemann integral provides a fundamental
        understanding of area and accumulation, which is critical in many real-world applications.
    </p>

</body>

<body>
    <title>Lebesgue vs Riemann Integration</title>
    <div>
        <label for="lowerBound">Lower Bound (a):</label>
        <input id="lowerBound" type="number" value="-2" step="0.1">
        <label for="upperBound">Upper Bound (b):</label>
        <input id="upperBound" type="number" value="2" step="0.1">
        <label for="numSlices">Number of Slices:</label>
        <input id="numSlices" type="number" value="10" min="1">
        <button onclick="plotIntegrals()">Plot Integrals</button>
    </div>

    <canvas id="riemannChart"></canvas>
    <canvas id="lebesgueChart"></canvas>


    <script>

        // Function to calculate the Riemann integral
        function calculate2Riemann(f, a, b, n) {
            const dx = (b - a) / n; // Width of each slice
            let totalArea = 0;

            for (let i = 0; i < n; i++) {
                const xMid = a + i * dx + dx / 2; // Midpoint of the slice
                const height = f(xMid); // Function value at midpoint
                totalArea += height * dx; // Area of the rectangle
            }

            return totalArea;
        }

        // Function to calculate the Lebesgue integral
        function calculate2Lebesgue(func, lower, upper, steps) {
            const dx = (upper - lower) / steps; // Width of each slice in the domain
            let values = [];

            // Step 1: Sample the function over the domain and store (x, y) pairs
            for (let i = 0; i < steps; i++) {
                const x = lower + i * dx; // Current x-value
                const y = func(x);       // Evaluate function at x
                values.push({ x, y });   // Store (x, y)
            }

            // Step 2: Sort the values by y (ascending) for Lebesgue integration
            values.sort((a, b) => a.y - b.y);

            // Step 3: Initialize variables for integration
            let lebIntegral = 0;        // Total Lebesgue integral
            let dy = values[0].y;       // Start with the smallest y-value
            let currentMeasure = 0;     // Accumulated "measure" (width in x)

            // Step 4: Traverse the sorted values to compute horizontal slices
            for (let i = 0; i < values.length; i++) {
                const y = values[i].y; // Current y-value

                // If the y-value changes, add the area of the previous band
                if (Math.abs(y - dy) > 1e-10) { // Significant change in y
                    lebIntegral += dy * currentMeasure; // Add area of the band
                    dy = y;                            // Update current y-value
                    currentMeasure = dx;               // Reset measure for the new band
                } else {
                    currentMeasure += dx; // Accumulate measure for the current band
                }
            }

            // Step 5: Add the area of the last band
            lebIntegral += dy * currentMeasure;

            // Return the computed Lebesgue integral
            return lebIntegral;
        }

        // Declare chart instances as global variables
        let riemannChart = null;
        let lebesgueChart = null;

        // List of functions to randomly choose from
        const functions = [
            { func: (x) => x ^ 2, label: "f(x) = x^2" },
            { func: (x) => x ^ 3, label: "f(x) = x^3" },
            { func: (x) => Math.abs(x), label: "f(x) = |x|" },
            { func: (x) => Math.exp(-x ^ 2), label: "f(x) = exp(-x^2)" },
            { func: (x) => Math.cos(x), label: "f(x) = cos(x)" },
            { func: (x) => Math.sqrt(Math.abs(x)), label: "f(x) = sqrt(|x|)" },
            { func: (x) => Math.log(Math.abs(x) + 1), label: "f(x) = log(|x| + 1)" },
            { func: (x) => Math.exp(x), label: "f(x) = exp(x)" },
            { func: (x) => Math.exp(-Math.abs(x)), label: "f(x) = exp(-|x|)" },
            { func: (x) => Math.sin(x) ^ 2, label: "f(x) = sin^2(x)" },
            { func: (x) => Math.cos(x) ^ 2, label: "f(x) = cos^2(x)" },
            { func: (x) => Math.pow(x, 4), label: "f(x) = x^4" },
            { func: (x) => Math.log2(Math.abs(x) + 1), label: "f(x) = log2(|x| + 1)" },
            { func: (x) => Math.floor(x), label: "f(x) = floor(x)" },
            { func: (x) => Math.ceil(x), label: "f(x) = ceil(x)" },
            { func: (x) => Math.abs(x ^ 3 - x), label: "f(x) = |x^3 - x|" },
        ];


        // Variables for user inputs
        let lowerBound = -2;
        let upperBound = 2;
        let numSlices = 10;
        let selectedFunction = functions[0]; // Default function

        // Function to calculate the Riemann integral
        function calculateRiemann(f, a, b, n) {
            const dx = (b - a) / n; // Width of each slice
            const rectangles = [];
            let totalArea = 0;

            for (let i = 0; i < n; i++) {
                const xMid = a + i * dx + dx / 2; // Midpoint of the slice
                const height = f(xMid); // Function value at midpoint
                totalArea += height * dx; // Area of the rectangle
                rectangles.push({ x: a + i * dx, dx, height }); // Store rectangle data for visualization
            }

            return { rectangles, totalArea };
        }

        // Plot Riemann graph
        function plotRiemann(f, a, b, n) {
            const { rectangles, totalArea } = calculateRiemann(f, a, b, n);

            const ctx = document.getElementById("riemannChart").getContext("2d");

            // Destroy previous chart if it exists
            if (window.riemannChart instanceof Chart) window.riemannChart.destroy();

            // Bar chart for Riemann rectangles
            window.riemannChart = new Chart(ctx, {
                type: "bar",
                data: {
                    labels: rectangles.map((r) => r.x.toFixed(2)), // X-coordinates
                    datasets: [
                        {
                            label: `Riemann Rectangles (Integral of ${selectedFunction.label} ≈ ${totalArea.toFixed(3)})`,
                            data: rectangles.map((r) => r.height), // Heights of rectangles
                            backgroundColor: "rgba(54, 162, 235, 0.5)", // Blue bars
                            borderWidth: 1,
                        },
                    ],
                },
                options: {
                    plugins: {
                        title: {
                            display: true,
                            text: `Riemann Integral Approximation (${selectedFunction.label}): ${totalArea.toFixed(3)}`,
                        },
                    },
                },
            });
        }

        // Function to calculate the Lebesgue integral with axes inverted
        function calculateLebesgue(func, lower, upper, steps) {
            const dx = (upper - lower) / steps; // Width of each slice in the domain
            let values = [];

            // Step 1: Sample the function over the domain and store (x, y) pairs
            for (let i = 0; i < steps; i++) {
                const x = lower + i * dx; // Current x-value
                const y = func(x); // Evaluate function at x
                values.push({ x, y }); // Store (x, y)
            }

            // Step 2: Sort the values by y (ascending) for Lebesgue integration
            values.sort((a, b) => a.y - b.y);

            // Step 3: Initialize variables for integration
            let lebIntegral = 0; // Total Lebesgue integral
            let dy = values[0].y; // Start with the smallest y-value
            let currentMeasure = 0; // Accumulated "measure" (width in x)
            const bands = []; // Store bands for visualization

            // Step 4: Traverse the sorted values to compute horizontal slices
            for (let i = 0; i < values.length; i++) {
                const y = values[i].y; // Current y-value

                // If the y-value changes, add the area of the previous band
                if (Math.abs(y - dy) > 1e-10) { // Significant change in y
                    lebIntegral += dy * currentMeasure; // Add area of the band
                    bands.push({ x: currentMeasure, y: dy }); // Store band data
                    dy = y; // Update current y-value
                    currentMeasure = dx; // Reset measure for the new band
                } else {
                    currentMeasure += dx; // Accumulate measure for the current band
                }
            }

            // Step 5: Add the area of the last band
            lebIntegral += dy * currentMeasure;
            bands.push({ x: currentMeasure, y: dy }); // Push the last band

            // Return the computed Lebesgue integral and bands
            return { bands, totalArea: lebIntegral };
        }

        // Plot the Lebesgue integral with inverted axes
        function plotLebesgue(func, lower, upper, steps) {
            const { bands, totalArea } = calculateLebesgue(func, lower, upper, steps);

            const ctx = document.getElementById("lebesgueChart").getContext("2d");

            // Destroy the previous chart if it exists
            if (window.lebesgueChart instanceof Chart) window.lebesgueChart.destroy();

            // Create the Lebesgue chart
            window.lebesgueChart = new Chart(ctx, {
                type: "bar",
                data: {
                    labels: bands.map((b) => b.x.toFixed(2)), // Widths of the bands (x-axis values)
                    datasets: [
                        {
                            label: `Lebesgue Integral (Area ≈ ${totalArea.toFixed(3)})`,
                            data: bands.map((b) => b.y), // Heights of the bands (y-axis values)
                            backgroundColor: "rgba(250, 150, 150, 0.5)", // Blue bars
                            borderColor: "rgba(250, 150, 150, 1)",
                            borderWidth: 1,
                        },
                    ],
                },
                options: {
                    indexAxis: "x", // Ensure the bars are vertical (x-axis is horizontal)
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: "Measure of Interval (x-width)",
                            },
                            beginAtZero: true,
                        },
                        y: {
                            title: {
                                display: true,
                                text: "Function Value (y)",
                            },
                            beginAtZero: true,
                        },
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: `Lebesgue Integral Approximation`,
                        },
                    },
                },
            });
        }

        // Plot both integrals
        function plotIntegrals() {
            lowerBound = parseFloat(document.getElementById("lowerBound").value);
            upperBound = parseFloat(document.getElementById("upperBound").value);
            numSlices = parseInt(document.getElementById("numSlices").value);

            // Choose a random function
            selectedFunction = functions[Math.floor(Math.random() * functions.length)];

            // Plot Riemann and Lebesgue integrals
            plotRiemann(selectedFunction.func, lowerBound, upperBound, numSlices);
            plotLebesgue(selectedFunction.func, lowerBound, upperBound, numSlices);

            // Calculate Riemann and Lebesgue integrals
            const riemannResult = calculate2Riemann(selectedFunction.func, lowerBound, upperBound, numSlices);
            const lebesgueResult = calculate2Lebesgue(selectedFunction.func, lowerBound, upperBound, numSlices);

            console.log("Riemann Integral:", riemannResult, "f:", selectedFunction.label, "a:", lowerBound, "b:", upperBound, "n:", numSlices);
            console.log("Lebesgue Integral:", lebesgueResult, "f:", selectedFunction.label, "a:", lowerBound, "b:", upperBound, "n:", numSlices);
        }

        // Initial plot
        plotIntegrals();
    </script>

</body>

</html>