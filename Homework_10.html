<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Homework #10</title>
    <link rel="stylesheet" href="css/styles.css">
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.9.4/Chart.js"></script>
</head>

<body>
    <a href="index.html">Home</a>
    <h1>Statistics - Homework #10 [Y.2024-2025]</h1>
    <h1>Theory and Research</h1>

    <h2>General Concept of Sampling Mean and Variance</h2>
    <p>
        In statistics, the <strong>sampling mean</strong> is the average of a set of data points. It is a measure of the
        central tendency of the data and is calculated by summing all the data points and dividing by the number of
        points:
        <br>
        <i>Sample Mean:</i>
        <br>
        \(\bar{x} = \frac{1}{n} \sum_{i=1}^{n} x_i \)
        <br>
        where \( x_1, x_2, \dots, x_n \) are the data points and \( n \) is the number of observations.
    </p>
    <p>
        The <strong>sampling variance</strong> measures the spread of the data points around the sample mean. It is
        computed by averaging the squared differences between each data point and the sample mean:
        <br>
        <i>Sample Variance:</i>
        <br>
        \( s^2 = \frac{1}{n-1} \sum_{i=1}^{n} (x_i - \bar{x})^2 \)
        <br>
        where \( \bar{x} \) is the sample mean and \( n \) is the number of data points.
    </p>
    <p>
        The <strong>sampling distribution</strong> of the sample mean and variance describes how these values behave
        over multiple samples. The mean of the sampling distribution of the sample mean is equal to the population mean,
        and the variance of the sampling distribution of the sample mean is the population variance divided by the
        sample size:
        <br>
        <i>Mean of Sampling Distribution:</i>
        <br>
        \( \mu_{\bar{x}} = \mu \)
        <br>
        <i>Variance of Sampling Distribution:</i>
        <br>
        \( \sigma^2_{\bar{x}} = \frac{\sigma^2}{n} \)
        <br>
        where \( \mu \) and \( \sigma^2 \) are the population mean and variance, respectively, and \( n \) is the sample
        size.
    </p>

    <h2>Lebesgue-Stieltjes Integration and Its Applications</h2>
    <p>
        The <strong>Lebesgue-Stieltjes integration</strong> is a generalization of the Lebesgue integral, developed to
        integrate functions with respect to a more general measure. It is an integral of a function \( f \) with respect
        to a measure \( \mu \) which is derived from a function \( G \), called the Stieltjes function. The
        Lebesgue-Stieltjes integral can be written as:
        <br>
        <i>Lebesgue-Stieltjes Integral:</i>
        <br>
        \( \int_a^b f(x) \, dG(x) = \int_a^b f(x) \, g'(x) dx \)
        <br>
        where \( g(x) \) is a function whose derivative \( g'(x) \) represents the measure \( \mu \). This form of
        integration is useful when the measure is not necessarily derived from a simple distribution, but from a more
        complex function \( G(x) \).
    </p>
    <p>
        One key application of Lebesgue-Stieltjes integration is in <strong>probability theory</strong>. When the
        cumulative distribution function (CDF) \( F(x) \) of a random variable is differentiable, the Lebesgue-Stieltjes
        integral provides a method of calculating the expected value of a random variable. If \( f(x) \) is the
        probability density function (PDF) of the random variable \( X \), then the expected value of \( X \) can be
        written as:
        <br>
        <i>Expected Value:</i>
        <br>
        \( E[X] = \int_{-\infty}^{\infty} x f(x) \, dx \)
        <br>
        where \( f(x) \) is the probability density function.
    </p>
    <p>
        In <strong>measure theory</strong>, Lebesgue-Stieltjes integration plays a vital role in defining integrals with
        respect to general measures, allowing the integration of more general functions and distributions than what is
        possible with Riemann integration. For example, it is crucial for integrating random variables with respect to
        measures that are not necessarily absolutely continuous, such as in the case of discrete distributions or
        distributions with singularities.
    </p>
    <p>
        The versatility of Lebesgue-Stieltjes integration has led to its use in various areas of mathematics and applied
        fields. In probability theory, it provides a framework for understanding and computing expectations in the
        context of both discrete and continuous random variables. It is also widely used in stochastic processes, where
        the integration process is used to model complex random phenomena and time-evolving systems.
    </p>

    <h2>Riemann Integration</h2>
    <p>
        The <strong>Riemann integral</strong> is the classical concept of integration in calculus, where we define the
        integral of a function over an interval by partitioning the interval into smaller subintervals, computing the
        sum of the function's values multiplied by the subinterval widths, and taking the limit as the partition gets
        finer. Mathematically, the Riemann integral of a function \( f \) over the interval \([a, b]\) is expressed as:
        <br>
        <i>Riemann Integral:</i>
        <br>
        \( \int_a^b f(x) \, dx = \lim_{\|P\| \to 0} \sum_{i=1}^{n} f(x_i^*) \Delta x_i \)
        <br>
        where \( P \) is a partition of the interval \([a, b]\), \( x_i^* \) is a sample point from each subinterval,
        and \( \Delta x_i \) is the width of the subinterval. The limit is taken as the norm of the partition \( \|P\|
        \) (the width of the largest subinterval) approaches 0.
    </p>
    <p>
        The Riemann integral is well-suited for integrating functions that are continuous over the interval \([a, b]\).
        However, it has limitations. Specifically, it does not handle discontinuous functions or functions with certain
        irregularities (e.g., functions with jumps or infinite discontinuities) well. This is where the Lebesgue
        integral, including Lebesgue-Stieltjes integration, becomes more powerful, as it can handle these types of
        functions by integrating with respect to a more general measure.
    </p>
    <p>
        Despite its limitations, the Riemann integral remains widely used in many areas of mathematics and applied
        sciences. It is often used for practical problems in physics, engineering, and economics, where the functions of
        interest are continuous and smooth over the region of integration. The Riemann integral provides a fundamental
        understanding of area and accumulation, which is critical in many real-world applications.
    </p>

</body>

<body>
    <title>Lebesgue vs Riemann Integration</title>
    <div>
        <label for="lowerBound">Lower Bound (a):</label>
        <input id="lowerBound" type="number" value="-2" step="0.1">
        <label for="upperBound">Upper Bound (b):</label>
        <input id="upperBound" type="number" value="2" step="0.1">
        <label for="numSlices">Number of Slices:</label>
        <input id="numSlices" type="number" value="10" min="1">
        <button onclick="plotIntegrals()">Plot Integrals</button>
    </div>

    <canvas id="riemannChart"></canvas>
    <canvas id="lebesgueChart"></canvas>

    <script src="integrals.js"></script>

    <script>
        // Declare chart instances as global variables
        let riemannChart = null;
        let lebesgueChart = null;

        // List of functions to randomly choose from
        const functions = [
            { func: (x) => x ^ 2, label: "f(x) = x^2" },
            { func: (x) => x ^ 3, label: "f(x) = x^3" },
            { func: (x) => Math.sin(x), label: "f(x) = sin(x)" },
            { func: (x) => Math.abs(x), label: "f(x) = |x|" },
            { func: (x) => Math.exp(-x ^ 2), label: "f(x) = exp(-x^2)" },
            { func: (x) => Math.cos(x), label: "f(x) = cos(x)" },
            { func: (x) => Math.tan(x), label: "f(x) = tan(x)" }, // Avoid vertical asymptotes with proper bounds
            { func: (x) => Math.sqrt(Math.abs(x)), label: "f(x) = sqrt(|x|)" },
            { func: (x) => Math.log(Math.abs(x) + 1), label: "f(x) = log(|x| + 1)" },
            { func: (x) => Math.exp(x), label: "f(x) = exp(x)" },
            { func: (x) => Math.exp(-Math.abs(x)), label: "f(x) = exp(-|x|)" },
            { func: (x) => x % 1, label: "f(x) = x % 1 (fractional part of x)" },
            { func: (x) => Math.sign(x), label: "f(x) = sign(x)" },
            { func: (x) => Math.sin(2 * x), label: "f(x) = sin(2x)" },
            { func: (x) => Math.sin(x) ^ 2, label: "f(x) = sin^2(x)" },
            { func: (x) => Math.cos(x) ^ 2, label: "f(x) = cos^2(x)" },
            { func: (x) => Math.pow(x, 4), label: "f(x) = x^4" },
            { func: (x) => x ^ (1 / 3), label: "f(x) = x^(1/3)" },
            { func: (x) => Math.log2(Math.abs(x) + 1), label: "f(x) = log2(|x| + 1)" },
            { func: (x) => Math.floor(x), label: "f(x) = floor(x)" },
            { func: (x) => Math.ceil(x), label: "f(x) = ceil(x)" },
            { func: (x) => Math.abs(x ^ 3 - x), label: "f(x) = |x^3 - x|" },
            { func: (x) => Math.atan(x), label: "f(x) = arctan(x)" },
            { func: (x) => Math.cbrt(x), label: "f(x) = cbrt(x) (cube root of x)" },
        ];


        // Variables for user inputs
        let lowerBound = -2;
        let upperBound = 2;
        let numSlices = 10;
        let selectedFunction = functions[7]; // Default function

        // Function to calculate Riemann rectangles
        function calculateRiemann(f, a, b, n) {
            const dx = (b - a) / n;
            const rectangles = [];
            let totalArea = 0;

            for (let i = 0; i < n; i++) {
                const xLeft = a + i * dx;
                const xMid = xLeft + dx / 2;
                const height = f(xMid);
                const area = height * dx;
                totalArea += area;

                rectangles.push({ x: xLeft, dx, height });
            }

            return { rectangles, totalArea };
        }

        // Plot Riemann graph
        function plotRiemann(f, a, b, n) {
            const { rectangles, totalArea } = calculateRiemann(f, a, b, n);

            const ctx = document.getElementById("riemannChart").getContext("2d");

            // Destroy previous chart if it exists
            if (riemannChart) riemannChart.destroy();

            // Bar chart for Riemann rectangles
            riemannChart = new Chart(ctx, {
                type: "bar",
                data: {
                    labels: rectangles.map((r) => r.x.toFixed(2)),
                    datasets: [
                        {
                            label: `Riemann Rectangles (Integral of ${selectedFunction.label} ≈ ${totalArea.toFixed(3)})`,
                            data: rectangles.map((r) => r.height),
                            backgroundColor: "rgba(54, 162, 235, 0.5)",
                            borderWidth: 1,
                        },
                    ],
                },
                options: {
                    plugins: {
                        title: {
                            display: true,
                            text: `Riemann Integral Approximation (${selectedFunction.label}): ${totalArea.toFixed(3)}`,
                        },
                    },
                    scales: {
                        x: { title: { display: true, text: "x" } },
                        y: { title: { display: true, text: "f(x)" } },
                    },
                },
            });
        }

        // Function to calculate the Lebesgue integral using horizontal bands
        function calculateLebesgue(f, a, b, n) {
            const dx = (b - a) / 1000; // Fine sampling for the width of x
            const functionValues = []; // Store sampled points (x, f(x))

            // Sample f(x) across the interval [a, b]
            for (let x = a; x <= b; x += dx) {
                functionValues.push({ x: x, y: f(x) });
            }

            // Determine the range of f(x) (min and max)
            const minY = Math.min(...functionValues.map((p) => p.y));
            const maxY = Math.max(...functionValues.map((p) => p.y));
            const dy = (maxY - minY) / n; // Vertical slice height for Lebesgue bands

            const bands = []; // Holds the information for positive and negative bands
            let totalPositiveArea = 0;
            let totalNegativeArea = 0;

            // For each horizontal band
            for (let i = 0; i < n; i++) {
                const lowerY = minY + i * dy;
                const upperY = lowerY + dy;

                // Filter the x-values where f(x) is within the band [lowerY, upperY)
                const widthSegments = functionValues.filter(
                    (point) => point.y >= lowerY && point.y < upperY
                );

                const totalWidth = widthSegments.length * dx; // Approximate width

                // Calculate the area for the band
                const bandArea = totalWidth * (lowerY + dy / 2); // Use mid-band height for accuracy

                if (lowerY > 0) {
                    totalPositiveArea += bandArea; // Add to positive area
                } else if (lowerY < 0) {
                    totalNegativeArea += bandArea; // Add to negative area
                }

                // Push the band information (positive and negative separately)
                bands.push({ y: lowerY + dy / 2, width: totalWidth });
            }

            return { bands, totalPositiveArea, totalNegativeArea };
        }

        // Plot the Lebesgue integral with horizontal bands
        function plotLebesgue() {
            const lowerBound = parseFloat(document.getElementById("lowerBound").value);
            const upperBound = parseFloat(document.getElementById("upperBound").value);
            const numSlices = parseInt(document.getElementById("numSlices").value);

            // Example function (cosine function)
            const f = (x) => Math.cos(x);

            // Calculate the Lebesgue integral
            const { bands, totalPositiveArea, totalNegativeArea } = calculateLebesgue(f, lowerBound, upperBound, numSlices);

            const ctx = document.getElementById("lebesgueChart").getContext("2d");

            // Destroy the previous chart if it exists
            if (lebesgueChart) lebesgueChart.destroy();

            // Create the Lebesgue chart
            lebesgueChart = new Chart(ctx, {
                type: "bar",
                data: {
                    labels: bands.map((b) => b.y.toFixed(2)), // y-values as labels
                    datasets: [
                        {
                            label: `Positive Area: ${totalPositiveArea.toFixed(3)}`,
                            data: bands.map((b) => (b.y > 0 ? b.width : 0)), // Positive bands
                            backgroundColor: "rgba(54, 162, 235, 0.5)", // Blue for positive areas
                        },
                        {
                            label: `Negative Area: ${totalNegativeArea.toFixed(3)}`,
                            data: bands.map((b) => (b.y < 0 ? b.width : 0)), // Negative bands
                            backgroundColor: "rgba(255, 99, 132, 0.5)", // Red for negative areas
                        },
                    ],
                },
                options: {
                    indexAxis: "y", // Flip axes for horizontal bars
                    plugins: {
                        title: {
                            display: true,
                            text: `Lebesgue Integral Approximation (f(x) = cos(x)): Positive: ${totalPositiveArea.toFixed(3)}, Negative: ${totalNegativeArea.toFixed(3)}`,
                        },
                    },
                    scales: {
                        y: { title: { display: true, text: "Width of x (dx)" } },
                        x: { title: { display: true, text: "f(x)" } },
                    },
                },
            });
        }

        // Plot both integrals
        function plotIntegrals() {
            lowerBound = parseFloat(document.getElementById("lowerBound").value);
            upperBound = parseFloat(document.getElementById("upperBound").value);
            numSlices = parseInt(document.getElementById("numSlices").value);

            // Choose a random function
            selectedFunction = functions[Math.floor(Math.random() * functions.length)];

            // Plot Riemann and Lebesgue integrals
            plotRiemann(selectedFunction.func, lowerBound, upperBound, numSlices);
            plotLebesgue(selectedFunction.func, lowerBound, upperBound, numSlices);
        }

        // Initial plot
        plotIntegrals();
    </script>

</body>

</html>